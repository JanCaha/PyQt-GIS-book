[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tvorba GUI aplikací pro geoinformatiku",
    "section": "",
    "text": "Předmluva\nU programování, stejně jako u mnoha jiných dovedností, lze rozlišovat různé úrovně komplexnosti, na nichž lze tuto dovednost provozovat.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "01-uvod.html",
    "href": "01-uvod.html",
    "title": "1  Úvod",
    "section": "",
    "text": "V této knize se zaměříme na základy tvorby aplikací s uživatelským rozhraním v programovacím jazyku Python s využitím knihovny PyQt. Hlavním důvod pro tuto kombinaci je fakt, že Python se řadí mezi nejrozšířenější a nejsnaději použitelné jazyky s širokým spektrem knihoven a frameworků, které usnadňují práci. Z hlediska geoinformatiky je Python zajímavý proto, že většina knihoven a softwarů pro zpracování prostorových dat poskytuje pro tento jazyk API (např. GDAL, PROJ, GEOS a další), většina GIS softwarů pak umožňuje pomocí Pythonu vytvářet extenze či skripty (např. GRASS, QGIS a další). PyQt je jedna z knihoven, skrze kterou lze v Pythonu tvořit aplikace s uživatelským rozhraním. Alternativami jsou např. Tkinter, Kivy, wxPython a další (Costa 2020). Důvodem pro volbu [PyQt]]{.sw} jsou jednak široké možnosti, které knihovna poskytuje (přes 440 tříd a cca 6000 funkcí), a také fakt, že kromě API (Application Programming Interface) pro samotné GUI (Graphical User Interface) poskytuje i doplňkovou funkcinalitu pro management běhu a funkčnosti aplikace. Tato knihovna je pro geoinformatiky zajímavá, protože QGIS je vytvořen s použitím knihovny Qt, a v případě tvorby pluginů programátor pracuje právě s PyQT.\nKombinace Pythonu, PyQt a geoinformatických knihoven tak poskytuje pro geoinformatiky ideální sadu nástrojů pro tvorbu jak jednoduchých, tak i komplexnějších desktopových aplikací s uživatelským rozhraním."
  },
  {
    "objectID": "01-uvod.html#předpoklady",
    "href": "01-uvod.html#předpoklady",
    "title": "1  Úvod",
    "section": "1.1 Předpoklady",
    "text": "1.1 Předpoklady\nText předpokládá, že čtenář je obeznámen s principy programování (zejména objektově orientovaného programování), programovacím jazykem Python, základní znalostí typů prvků uživatelského rozhraní a alespoň základní znalostí knihovny GDAL (GDAL/OGR contributors 2022) a jejího Pythonového API. S ohledem na zaměření na geoinformatiku, se také předpokládá že čtenář je obeznámen se softwarem QGIS, který bude používán jako příklad pro vysvětlení některých principů. Tyto poznámky odkazující na QGIS vypadají následně.\n\n\n  \n  \n  \n  \n  \n  QGIS\n  \n  \n  \n  \nPoznámky odkazující k QGISu.\n\n      \n      \n\nPro seznámení s Python API GDAL lze doporučit publikaci Python GDAL/OGR Cookbok (Erickson et al. 2013), která na praktických případech demonstruje základní principy použití této knihovny. Podobné příklady lze pak najít i v knize Geoprocessing With Python (Garrard 2016).\nPři práci s [PyQt]]{.sw} je mnoho situací, kdy lze volit mezi použitím funkcí z PyQt a pythonových knihoven. Volba mezi nimi je v takovém případě spíše osobní volbou programátora, jeho obeznámenosti s danou technologií, či propojením na další použité nástroje a knihovny. V mnoha situacích nelze specificky určit, že by jeden z přístupů byl lepší či vhodnější. Autor se ve většině případů kloní spíše k použití pythonových knihoven, a tento přístup se bude promítat do ukázkových kódů v publikaci.\n\n\n\n\n\n\nQT Třídy vs. Python třídy nebo moduly\n\n\n\nPříkladem zaměnitelné funkcionality může být např. třída QDir() (z modulu PyQt5.QtCore) a třída Path() (z modulu pathlib ). Obě položky poskytují v principu velice podobné funkce a možnosti.\n\n\nPři psaní kódu v Pythonu budeme používat modul typing (Python Software Foundation 2022), a typovat proměnné, jednak z důvodu zlepšení čitelnosti kódu a jednak proto, že většina IDE v takovém případě bude lépe napovídat funkce, argumenty atd. Ukázka pythonového kódu s typováním parametrů, návratového typu a proměnných:\n\ndef layer_count(filename: str) -> int:\n    ds: ogr.Datasource = ogr.Open(filename)\n    return ds.GetLayerCount()\n\n\n\n\n\n\n\nCOSTA, Claire D., 2020. Top 10 python GUI frameworks for developers [online] [cit. 2022-08-01]. Dostupné z: https://towardsdatascience.com/top-10-python-gui-frameworks-for-developers-adca32fbe6fc\n\n\nERICKSON, Jared, Cort DANIEL and Michael PAYNE, 2013. Python GDAL/OGR cookbook [online]. Dostupné z: https://pcjericks.github.io/py-gdalogr-cookbook/\n\n\nGARRARD, Chris, 2016. Geoprocessing with python. Shelter Island, NY: Manning Publications. ISBN 978-1-61729-214-9.\n\n\nGDAL/OGR CONTRIBUTORS, 2022. GDAL/OGR geospatial data abstraction software library [online]. B.m.: Open Source Geospatial Foundation. Dostupné z: https://gdal.org\n\n\nPYTHON SOFTWARE FOUNDATION, 2022. Typing — support for type hints [online]. Dostupné z: https://docs.python.org/3.8/library/typing.html"
  },
  {
    "objectID": "02-qt.html",
    "href": "02-qt.html",
    "title": "2  Knihovna Qt a její Python binding PyQt",
    "section": "",
    "text": "Knihovna Qt je multiplatformní knihovnou jazyka C++ pro tvorbu uživatelského rozhraní a aplikací. Podporuje mimo jiné operační systémy Linux, Windows, Android, macOS a další. Tyto vlastnosti výrazně usnadňují vývoj, neboť lze jednu aplikaci aplikaci spouštět na vícero platformách bez nutnosti výraznějších úprav. Na vývoji knihovny se od roku 1991 podílelo několik firem, aktuálně má vývoj na starosti firma The Qt Company. Knihovna je k dispozici jak pod Open Source, tak i komerční licencí.\n\n\n\nObr. 2.1: Qt Logo\n\n\nSamotná knihovna se dělí na několik dílčích částí, které obstarávají různou funkcionalitu aplikací. Existují např. speciální moduly pro GUI, Widgety (prvky uživatelského prostředí), multimédia, SQL a další. Pro potřeby menších aplikací je důležitých pouze několik hlavních modulů.\nMezi software používající knihovnu Qt se řadí např. Autodesk 3ds Max, Calibre, Google Earth, QGIS, Scribus, Stellarium, VirtualBox, VLC media player, XnView MP a další. Knihovnu mimo jiné využívají i některé Linuxové distribuce pro tvorbu uživatelských rozhraní na obecnější úrovni, než jsou konkrétní aplikace. Tato široká základna softwarů, spoléhajících na Qt, by měla zajišťovat jak stabilitu knihovny tak i její vývoj do budoucna."
  },
  {
    "objectID": "02-qt.html#pyqt",
    "href": "02-qt.html#pyqt",
    "title": "2  Knihovna Qt a její Python binding PyQt",
    "section": "2.2 PyQt",
    "text": "2.2 PyQt\nPyQt je propojení (angl. binding) z Pythonu na C++ knihovnu Qt , vyvinuté zcela nezávisle na knihovně Qt firmou Riverbank Computing. Jedná se v podstatě pouze o překlopení a zpřístupnění C++ API v Pythonu. Existuje i alternativní binding v podobě knihovny PySide, což je konkurence PyQt přímo od tvůrců Qt, které je ale v praxi o něco méně používaná. Co se použitelnosti týká jsou obě knihovny velice podobné a mezi kódem obou knihoven lze poměrně snadno přecházet.\n\n\n\nObr. 2.2: PyQt Logo\n\n\nPro psaní samotné aplikace budeme používat [PyQt5]]{.sw} (pro verzi Qt 5.x), ačkoliv již existuje i PyQt6, která zatím ale není příliš používána. Např. QGIS se připravuje v dohledné době na přechod z verze Qt 5.x na verzi 6.x. Přechod mezi verzemi by měl být v podstatě formalitou."
  },
  {
    "objectID": "02-qt.html#dokumentace",
    "href": "02-qt.html#dokumentace",
    "title": "2  Knihovna Qt a její Python binding PyQt",
    "section": "2.3 Dokumentace",
    "text": "2.3 Dokumentace\nVzhledem k tomu, že PyQt je pouze binding C++ knihovny, budeme odkazovat na dokumentaci přímo knihovny Qt, která je výrazně detailnější a více deskriptivní, než existující pythonové dokumentace PyQt."
  },
  {
    "objectID": "03-aplikace-s-gui.html",
    "href": "03-aplikace-s-gui.html",
    "title": "3  Aplikace s GUI",
    "section": "",
    "text": "Zásadní odlišností aplikací s uživatelským rozhraním a menšími skripty, či aplikacemi pro příkazovou řádku, spočívá ve faktu, že zatímco tyto jednodušší aplikace mají jasně určený počátek a konec a kód mezi nimi je prováděn lineárně, v GUI aplikacích se kód vykonává na základě interakce uživatele s programem. To vyžaduje principiálně jiný přístup ke kódu, jednak z hlediska managentu kódu, ale i mentálně. Běh programu není v tomto případě řízen pouze strukturou kódu, ale navíc i akcemi, které se uživatel provede v GUI.\nGUI aplikace po spuštění inicializují nekonečnou smyčku, která čeká na vstupy (v podobě interakce s GUI) od uživatele, na něž následně reaguje, obvykle spouštěním dílčích částí kódu aplikace. Tato nekonečná smyčka končí až uzavřením aplikace. Už pouze tato funkcinalita je na vytvoření netriviální, naštěstí PyQt tento process zjednodušuje na naprosté minimum. V modulu PyQt5.QtWidgets existuje třída QApplication, která se postará o vytvoření aplikace a management akcí v této aplikaci, aniž by bylo nutné ze strany programátora do tohoto procesu výrazněji zasahovat.\nV pythonu vytvoříme aplikaci jednoduše:\nV tomto bloku kódu je vhodné vysvětlit několik konstrukcí. sys.argv jsou argumenty příkazové řádky, ve formě seznamu s textovými hodnotami, s nimiž byl tento python spuštěný. Pokud aplikace nemusí podporovat argumenty příkazové řádky, lze zde předat i prázdný seznam []. Samotná aplikace se spustí příkazem app.exec().\nTímto voláním se spustí samotná aplikace a její nekončná smyčka, pro interakci s uživatelem. Takto vytvořená aplikace poběží do nekonečna a není ani jak zjevně ukončit, neboť jsme jí nepřiřadili žádné GUI. Konstrukce sys.exit() ukončí Python v momentě kdy se ukončí příkaz uvnitř závorek. V tomto případě se Python ukončí jakmile se ukončí aplikace.\nChceme-li vytvořené aplikaci přidat nějaké GUI vytvoříme tzv. hlavní okno (QMainWindow). Každá aplikace by ideálně měla mít takovéto hlavní okno s nímž uživatel pracuje. Existence hlavního okna není nezbytnou podmínkou, aplikace může fungovat i bez něj, pouze s dílčími okny, ale z uživatelského hlediska je rozumnější, pokud toho hlavní okno existuje.\nPři spuštění tohoto kódu se již aplikace zobrazí, byť s prázdným oknem (Obr. 3.1), a lze i ji korektně ukončit kliknutím na ikonu křížku (či jiného prvku, dle nastavení systému). Aplikace je otevřená v poměrně malém okně, což je výchozí stav, protože neobsahuje žádné GUI elementy. PyQT řeší základní funkčnost aplikace, tzv. minimalizaci, maximalizaci GUI a ukončení aplikace. Díky tomu těmto položkám nemusí věnovat pozornost programátor. Mimo to v aplikaci běží již zmíněná smyčka, čekající na interakci s uživatelem. Díky ní bude, jakmile do aplikace přidáme ovládací prvky, možné s aplikací interagovat.\nUkázkový kód pro tuto aplikaci je dostupný jako příklad: empty_application.py.\nAplikace přejímají nativně vzhled ze systému, aby se co nejlépe integrovaly do stávajícího vizuálního stylu operačního systému. Toto chování lze změnit. Pro potřeby těchto skript budeme předpokládat, že je žádoucí, aby aplikace používaly systémový vzhled."
  },
  {
    "objectID": "03-aplikace-s-gui.html#aplikace-bez-gui",
    "href": "03-aplikace-s-gui.html#aplikace-bez-gui",
    "title": "3  Aplikace s GUI",
    "section": "3.1 Aplikace bez GUI",
    "text": "3.1 Aplikace bez GUI\nQt řeší i problematiku aplikací, které nemají GUI, ale přesto vyžadují běhovou smyčku, která reaguje na vnější vstupy. Typicky se jedná o aplikace, které čekají na zprávu, kterou obvykle obdrží po síti. Na základě této zprávy, spustí aplikace odpovídající řetězec akcí. Stejně tak může aplikace v pravidelném intervalu kontrolovat data a v případě jejich změny provést nějakou akci. Tento typ aplikací nemusí řešit interakce s GUI, je tedy funkčně značně jednodušší. V modulu PyQt5.QtCore je pro tyto situace třída QCoreApplication, která je určena pro tvorbu aplikací bez uživatelského rozhraní."
  },
  {
    "objectID": "04-prvky-gui.html",
    "href": "04-prvky-gui.html",
    "title": "4  Prvky GUI",
    "section": "",
    "text": "Knihovna Qt poskytuje řadu prvků uživatelského rozhraní. Pro přehled prvků lze použít Qt Designer, což je grafický nástroj pro tvorbu uživatelského rozhraní.\nMezi tyto prvky se řadí např: popisky (QLabel), tlačítka (QPushButton), přepínače (QRadioButton), zaškrtávací pole (QCheckBox), několik druhů prvků pro editaci text (např. QLineEdit, QPlainTextEdit či QTextEdit), rozbalovací seznam (QComboBox), spinnery pro celá a desetinná čísla (QSpinBox a QDoubleSpinBox) (viz Obr. 4.1), posuvníky (QSlider či QDial), ukazatel postupu (QProgressBar), prvky pro výběr času či data (QTimeEdit, (QDateEdit a (QDateTimeEdit). Mimo to existují ještě specializované varianty prvků, například QFontComboBox jako varianta QComboBox speciálně zaměřená na výběr fontů, či speciální prvky pro rendrování HTML stránek - QWebView (viz Obr. 4.2).\nDále pak existují prvky pro zobrazení komplexnějších struktur jako jsou např. seznamy (QListWidget nebo QListView), tabulky (QTableView nebo QTableWidget) či stromové struktury (QTreeView nebo QTreeWidget) ale i jiné (viz Obr. 4.3).\nDále pak existují prvky, které umožňují různé strukturování GUI, respektive prvků v něm. Mezi ty patří např. QGroupBox, QGroupBox, QTabWidget, QStackedWidget a další."
  },
  {
    "objectID": "04-prvky-gui.html#rozložení-prvků-gui",
    "href": "04-prvky-gui.html#rozložení-prvků-gui",
    "title": "4  Prvky GUI",
    "section": "4.1 Rozložení prvků GUI",
    "text": "4.1 Rozložení prvků GUI\nPrvky GUI v aplikaci neexistují samy o sobě, ale vždy uspořádané do nějaké struktury. Základem této struktury je třída QLayout, která specifikuje základní chování rozvržení (layoutu) (The Qt Company Ltd. 2022). Základní rozvržení, existující přímo jako Qt třídy jsou QHBoxLayout a QVBoxLayout, které skládají prvky do horizontální potažmo vertikální struktury, QFormLayout, používá dva sloupce - popisku a samotné prvky, a QGridLayout, což je nejkomplexnější layout, kde je možné specifikovat počet sloupců, řádků a následně přiřazovat prvky GUI do jedné či několik takto vzniklých buněk.\n\n\n\nObr. 4.4: Ukázky jednotlivých rozvržení\n\n\nV rámci jednoho QWidget, či jiného GUI prvku může existovat několik layoutů, které do sebe mohou být i různě zanořené. Tím vznikají komplexní prvky GUI.\n\n\n\n\nTHE QT COMPANY LTD., 2022. Layout management [online] [cit. 2022-09-16]. Dostupné z: https://doc.qt.io/qt-5/layout.html"
  },
  {
    "objectID": "05-qmainwindow.html",
    "href": "05-qmainwindow.html",
    "title": "5  Jednoduchá aplikace",
    "section": "",
    "text": "V této kapitole sestavíme jednoduchou aplikaci, na níž budeme prakticky demonstrovat základní koncepty. Aplikace umožní uživateli vybrat soubor, následně zobrazí cestu k tomuto souboru a pokusí se soubor oveřít jako vektorový datový zdroj pomocí OGR a zobrazí informaci, zda-li je možné soubor otevřít pomocí OGR. Základem většiny aplikací je třída QMainWindow."
  },
  {
    "objectID": "05-qmainwindow.html#qmainwindow",
    "href": "05-qmainwindow.html#qmainwindow",
    "title": "5  Jednoduchá aplikace",
    "section": "5.1 QMainWindow",
    "text": "5.1 QMainWindow\nQMainWindow z modulu PyQt5.QtWidgets je třída, která poskytuje základní rozhraní aplikace. V tomto rozhraní jsou předchystané položky pro všechny v aplikacích obvyklé prvky (viz Obr. 5.1) např. menu (Menu bar), lišty s nástroji (Toolbars), uživatelsky umisťované widgety (Dock Widgets), též zvané dokovatelné widgety, stavový řádek (Status bar) a hlavní prostor aplikace (Central Widget).\n\n\n\nObr. 5.1: Součásti QMainWindow. Zdroj: (The Qt Company Ltd. 2022)\n\n\nMimo to může aplikace vytvářet další samostatná okna, s další funkcionalitou.\n\n\n  \n  \n  \n  \n  \n  QGIS\n  \n  \n  \n  \nJako samostatná okna fungují například Atributová tabulka, nebo Rozvžení (Layout) v QGIS.\n\n      \n      \n\nZákladním stavebním prvkem GUI v PyQt je QWidget, tento objekt je základem všech prvků uživatelského rozhraní a definuje obecné a pro všechny prvky GUI společné chování, nastavení a možnosti. Později si také ukážeme, jak lze na základě této třídy vytvářet vlastní prvky GUI.\n\n\n\n\n\n\nTODO !!!\n\n\n\ndoplnit odkaz na kapitolu\n\n\nRozložení QMainWindow umožňuje specifikaci jednoho hlavního widgetu (v Obr. 5.1 položka Centra Widget). V tomto widgetu by se měla nacházet hlavní a nejdůležitější část aplikace.\n\n\n  \n  \n  \n  \n  \n  QGIS\n  \n  \n  \n  \nV QGISu je hlavním widgetem mapové pole (třída QgsMapCanvas) spolu s několika drobnými widgety pod mapovým polem, kolem kterého jsou umístěně dokovatelné widgety Prohlížeč, Vrstvy a volitelně další, např. Nástroje zpracování."
  },
  {
    "objectID": "05-qmainwindow.html#aplikace",
    "href": "05-qmainwindow.html#aplikace",
    "title": "5  Jednoduchá aplikace",
    "section": "5.2 Aplikace",
    "text": "5.2 Aplikace\nVětšinu konceptů QMainWindow si můžeme demonstrovat na jednoduché aplikaci. Sestavíme aplikaci, kde uživatel vybere soubor, aplikace zobrazí cestu k tomuto souboru a pokusí se soubor otevřít jako vektorový datový zdroj pomocí OGR a zobrazí informaci, zda-li jde soubor otevřít pomocí OGR.\nSamotný kód pro tuto aplikaci může vypadat následovně:\n\n\nZdrojový kód\nimport sys\nfrom osgeo import ogr\nfrom PyQt5.QtWidgets import (QApplication, QMainWindow, QFormLayout,\n                             QToolButton, QLineEdit, QFileDialog, QWidget,\n                             QMenu, QAction)\n\n\nclass MainWindow(QMainWindow):\n\n    def __init__(self, *args, **kwargs):\n        super(MainWindow, self).__init__(*args, **kwargs)\n\n        self.setWindowTitle(\"První Aplikace\")\n        self.setMinimumSize(500, 200)\n\n        self.ds = None\n\n        self.init_gui()\n\n    def init_gui(self):\n\n        menu = QMenu('Aplikace', self)\n        self.menuBar().addMenu(menu)\n\n        self.action_end = QAction(\"Ukončit\", self)\n        self.action_end.triggered.connect(self.exit)\n\n        menu.addAction(self.action_end)\n\n        self.central_widget = QWidget()\n        self.setCentralWidget(self.central_widget)\n\n        layout = QFormLayout(self.central_widget)\n        self.central_widget.setLayout(layout)\n\n        self.select_file = QToolButton()\n        self.select_file.setText(\"Vyberte soubor\")\n        self.select_file.clicked.connect(self.open_file)\n\n        self.file_path = QLineEdit(\"\")\n        self.file_path.setReadOnly(False)\n\n        self.ogr_file = QLineEdit(\"\")\n        self.ogr_file.setReadOnly(False)\n\n        layout.addWidget(self.select_file)\n        layout.addRow(\"Vybraný soubor:\", self.file_path)\n        layout.addRow(\"Otevřít pomocí OGR:\", self.ogr_file)\n\n    def exit(self):\n        app = QApplication.instance()\n        app.quit()\n\n    def open_file(self) -> None:\n\n        filename, _ = QFileDialog.getOpenFileName(self, \"Vyberte soubor\")\n\n        if filename:\n            self.file_path.setText(filename)\n\n            self.ds = ogr.Open(filename, True)\n\n            if self.ds:\n                self.ogr_file.setText(\"Otevřeno OGR!\")\n            else:\n                self.ogr_file.setText(\"Nelze otevřít pomocí OGR!\")\n\n            self.statusBar().showMessage(\n            \"Soubor `{}` vybrán a zkušebně otevřen.\".format(filename), 2000)\n\n        else:\n            self.file_path.setText(\"\")\n            self.ogr_file.setText(\"\")\n\n\nif __name__ == \"__main__\":\n\n    app = QApplication(sys.argv)\n    mw = MainWindow()\n    mw.show()\n    sys.exit(app.exec())\n\n\nVýsledná aplikace vypadá následovně:\n\n\n\nObr. 5.2: Aplikace z předešlého kódu\n\n\nHlavní částí aplikace je třída odvozená od QMainWindow, kterou jsme pojmenovali MainWindow. Tato třída si ponechává veškeré svoje chování a lze ho rozšiřovat pomocí nově definovaných funkcí.\nV rámci funkce __init__(), nastavíme třídě titulek zobrazený v záhlaví aplikace a následně základní rozměr, který bude okno zabírat. V tomto případě \\(800 \\times 200\\) pixelů.\n\nself.setWindowTitle(\"První Aplikace\")\nself.setMinimumSize(500, 200)\n\nNásledně vytvoříme funkci init_gui(), která se stará o vytvoření samotného GUI v třídě MainWindow. Základem pro GUI je prázdný QWidget, který nastavíme jako centrální pro hlavní okno. Tento widget bude dále sloužit jako kontejner pro další prvky uživatelského rozhraní.\n\nself.central_widget = QWidget(self)\nself.setCentralWidget(self.central_widget)\n\nZákladem uživatelského rozhraní je layout, který specifikuje, jak budou prvky rozloženy v rozhraní. Pro tuto jednoduchou aplikaci zvolíme QFormLayout, což je layout, kde přídáváme prvky do řádků, přičemž každý řádek obsahuje popisku a prvek GUI. Dříve vytvořenému widgetu přiřadíme vytvořený layout, který se postará o rozložení prvků. Při tvorbě jak QFormLayout, tak i QWidget, předáváme jako parameter self, což je odkaz na vytvořenou instanci MainWindow. Tato položka slouží jako tzv. rodičovský prvek. Rodičovský prvek slouží v rámci Qt jako prevence, aby nebyly z paměti smazány objekty, pokud jsou ještě zapotřebí. Rodičovský prvek zajišťuje, že prvek nebude smazát, dokud není ke smazání z paměti určen prvek rodičovský. Při tvorbě některých prvků GUI se jedná o dobrou praxi, která předchází problémům s management existujících prvků GUI.\n\nlayout = QFormLayout(self.central_widget)\nself.central_widget.setLayout(layout)\n\nNásledně vytvoříme tři prvky GUI. Prvním bude QToolButton, kterému přiřadíme popisku vysvětlující jeho účel. Následně propojíme událost na tomto prvku clicked s funkcí (open_file()), kterou jsme vytvořili v třídě MainWindow. Toto propojení se děje v terminologii Qt pomocí tzv. signálů a slotů, jejichž detaily budou vysvětleny později. Toto tlačítko je zároveň jediný opravdu interaktivní prvek v GUI, ostatní prvky jsou pasivní a budou pouze zobrazovat informace.\n\nself.select_file = QToolButton()\nself.select_file.setText(\"Vyberte soubor\")\nself.select_file.clicked.connect(self.open_file)\n\nNásledně vytvoříme dva prvky typu QLineEdit, což prvek pro vstup textu, který je omezen na velikost jednoho řádku. Oba prvky ale nastavíme pouze pro čtení, čímž znemožníme uživateli, abych do těchto prvků psal. Budou složit pouze pro zobrazení textu, vytvořeného v rámci běhu programu.\n\nself.file_path = QLineEdit(\"\")\nself.file_path.setReadOnly(False)\nself.ogr_file = QLineEdit(\"\")\nself.ogr_file.setReadOnly(False)\n\nVšechny tři prvky následně vložíme do již existujícího layoutu. Tlačítko vložíme jako samostatný prvek, textové elementy spolu s popiskou.\n\nlayout.addWidget(self.select_file)\nlayout.addRow(\"Vybraný soubor:\", self.file_path)\nlayout.addRow(\"Otevřít pomocí OGR:\", self.ogr_file)\n\nMimo to ještě v aplikaci vytvoříme menu (QMenu) a vložíme do něj jednu položku ( QAction). K této položce opět připojíme funkci z naší třídy (exit()).\n\nmenu = QMenu('Aplikace', self)\nself.menuBar().addMenu(menu)\nself.action_end = QAction(\"Ukončit\", self)\nself.action_end.triggered.connect(self.exit)\nmenu.addAction(self.action_end)\n\n\n\n\n\n\n\nPropojení slotu na signál\n\n\n\nPři propojení funkce na signál, ve funkci connect(), si povšimněte, že se na funkci odkazuje jako na self.nazev_funkce a nikoliv self.nazev_funkce(). Funkce connect() totiž požaduje odkaz na objekt, což v pythonu může být i funkce, a nikoliv volání (spuštění) funkce, což by byl druhý případ.\n\n\nTakto vytvořená třída by již mohla existovat a GUI by existovalo, nicméně dokud nedefinujeme dvě použité funkce, bude nefunkční a program se korektně nespustí. Pokud bychom zakomentovali dva řádky, kde se používá funkce connect() bylo by možné program spustit.\nFunkce propojená s položkou v menu, je velice jednoduchá. Získá objekt aplikace a ukončí ho. Prvek QApplication je tzv. singleton, což znamená že je v rámci běhu programu existuje pouze jednou, není tedy nutné ho předávat do dílčích tříd, ale lze ho vždy jednoduše získat voláním QApplication.instance(). To značně zjednodušuje jeho použití skrze celou aplikaci.\n\ndef exit(self):\n    app = QApplication.instance()\n    app.quit()\n\nDruhá námi definovaná funkce, nechá uživatele vybrat soubor pomocí okna (které je svou strukturou známe, neboť se standardně používá). Pokud uživatel vybere soubor, bude proměnná filename obsahovat cestu a název souboru, v opačném případě bude mít hodnotu None. Textovému poli pro název souboru nastavíme cestu k souboru.Následně zkusíme soubor otevřít jako vektorová data, pomocí funkce ogr.Open(). Pokud se to povede nastavíme do textového pole informaci, že soubor byl pomocí OGR úspěšně otevřen. Pokud nelze soubor otevřít, zobrazíme o tom textovou zprávu. Následně do status baru (umistěného zcela dole v okně) zobrazíme zprávu, že byl soubor zkušebně otevřen. Zpráva bude zobrazena po dobu 2 vteřin (2000 milisekund).\n\ndef open_file(self) -> None:\n\n    filename, _ = QFileDialog.getOpenFileName(self, \"Vyberte soubor\")\n\n    if filename:\n        self.file_path.setText(filename)\n\n        self.ds = ogr.Open(filename, True)\n\n        if self.ds:\n            self.ogr_file.setText(\"Otevřeno OGR!\")\n        else:\n            self.ogr_file.setText(\"Nelze otevřít pomocí OGR!\")\n\n        self.statusBar().showMessage(\n        \"Soubor `{}` vybrán a zkušebně otevřen.\".format(filename), 2000)\n\n    else:\n        self.file_path.setText(\"\")\n        self.ogr_file.setText(\"\")    \n\nTímto se nám povedlo vytvořit minimalistickou GUI aplikaci. Její funkcionalita je značně omezená, ale lze na ní vhodně demonstrovat důležité základní koncepty tvorby aplikací s použítím PyQt. Kód aplikace je dostupný zde: open_ogr_file.py.\n\n\n\n\nTHE QT COMPANY LTD., 2022. Qt 5.15 [online] [cit. 2022-08-13]. Dostupné z: https://doc.qt.io/qt-5/"
  },
  {
    "objectID": "06-signály-sloty.html",
    "href": "06-signály-sloty.html",
    "title": "6  Signály a sloty",
    "section": "",
    "text": "V terminologii Qt jsou signály a sloty (The Qt Company Ltd. 2022) v podstatě implementací návrhového vzoru Observer (Wikipedia 2022). Tento návrhový vzor řeší situaci, kdy na změny jednoho objektu má reagovat jeden či více jiných objektů, přičemž chceme minimalizovat provázanost mezi těmito objekty.\nSignál je speciální objekt Qt, který má metodu emit(), jíž dáváme v daném kódu najevo, že nastala příslušná událost. Objekty mohou mít celou řadu signálů, pro různé situace či změny, které na těchto objektech mohou nastat. Pro použití s PyQt je důležité, že objekt, který chce signály používat, musí být odvozen od třídy QObject, která implementuje základní chování signálů. Většina objektů PyQt je z této třídy odvozena, u prvků GUI se to týká zcela všech, takže pro tyto objekty se nejedná o problém. Nicméně pokud chce programátor použít signály na vlastních pythonových třídách, musí je odvodit od QObject."
  },
  {
    "objectID": "06-signály-sloty.html#signál-bez-parameterů",
    "href": "06-signály-sloty.html#signál-bez-parameterů",
    "title": "6  Signály a sloty",
    "section": "6.1 Signál bez parameterů",
    "text": "6.1 Signál bez parameterů\nNejlepším vysvětlením bude jednoduchý příklad. Vytvoříme jednoduchý object Test, který bude mít rodičovský prvek QObject. V tomto prvku vytvoříme jednu proměnnou value a jeden signál valueChanged. Všimněte si, že signál se typicky vytváří mimo funkci __init__(), což je z pythonového hlediska nezvyklé, ale signál je proměnná celé třídy a nikoliv konkrétní instance (Tagliaferri 2021).\nObjektu vytvoříme jednu funkci set_value(), pomocí které budeme nastavovat hodnotu proměnné value. Jakmile tuto hodnotu nastavíme, vyvoláme příslušný signál (self.valueChanged.emit()).\nSamotné vyvolání signálu ale nevede k žádné akci, dokud k němu nepřipojíme slot. Slotem může být libovolná funkce v Pythonu, ať již navázaná na objekt, či existující samostatně. Pro tento příklad si vytvoříme jednoduchou funkci print_value_changed(), která pouze vytiskne před definovou zprávu.\nV běhové části kódu pak vytvoříme instanci třídy Test nazvanou jendoduše o, jako objekt. Pomocí konstrukce o.valueChanged.connect(print_value_changed) připojíme (connect()) k signálu valueChanged funkci print_value_changed().\n\n\n\n\n\n\nPropojení slotu na signál\n\n\n\nPři propojení funkce na signál, ve funkci connect(), si povšimněte, že se na funkci odkazuje jako na nazev_funkce a nikoliv nazev_funkce(). Funkce connect() totiž požaduje odkaz na objekt, což v pythonu může být i funkce, a nikoliv volání (spuštění) funkce, což by byl druhý případ.\n\n\nKdyž pak následně na objektu o zavoláme funkci o.set_value(5), dojde automaticky k vypsání zprávy z funkce print_value_changed(). Tato funkce totiž čeká na vyvolání signálu a jakmile k němu dojde, zcela automaticky se funkce spustí.\nhttps://www.pythonguis.com/tutorials/pyqt-signals-slots-events/\n\nfrom PyQt5.QtCore import QObject, pyqtSignal\n\n\nclass Test(QObject):\n\n    valueChanged = pyqtSignal()\n\n    def __init__(self) -> None:\n        super().__init__(None)\n        self.value = 0\n\n    def set_value(self, value: int) -> None:\n        self.value = value\n        self.valueChanged.emit()\n\n\ndef print_value_changed():\n    print(\"Test object value changed\")\n\n\nif __name__ == \"__main__\":\n    o = Test()\n    o.valueChanged.connect(print_value_changed)\n    o.set_value(5)\n\nSlot lze od signálu i odpojit pomocí konstrukce o.valueChanged.disconnect(print_value_changed). Další volání funkce o.set_value() by pak již nevedlo k výpisu připravené textové zprávy."
  },
  {
    "objectID": "06-signály-sloty.html#signál-s-parametry",
    "href": "06-signály-sloty.html#signál-s-parametry",
    "title": "6  Signály a sloty",
    "section": "6.2 Signál s parametry",
    "text": "6.2 Signál s parametry\nKromě jednoduchých signálů, které jsou pouze vyvolány v určitý moment a spustí nějakou specifickou funkci, lze vytvářet signály, které jsou vyvolány se specifickými parametry, které se automaticky předají funkci na slotu.\nPoužijeme stejný příklad jako výše. Pouze upravíme definici signálu tak, že bude přijímat dva paramtery typu integer a datetime. Když bude signál vyvoláván, předáme mu jako parametry hodnotu nastavovanou do proměnné a aktuální datum a čas. Následně upravíme funkci print_value_changed(), aby přijímala dva parametry příslušných typů a rozšíříme textovou zprávu o tyto dva údaje. Nyní tato funkce vytiskne infomaci o změně hodnoty na novou hodnotu (včetně hodnoty) a čas kdy se tato změna udála.\n\nfrom datetime import datetime\n\nfrom PyQt5.QtCore import QObject, pyqtSignal\n\n\nclass Test(QObject):\n\n    valueChanged = pyqtSignal(int, datetime)\n\n    def __init__(self) -> None:\n        super().__init__(None)\n        self.value = 0\n\n    def set_value(self, value: int) -> None:\n        self.value = value\n        self.valueChanged.emit(value, datetime.now())\n\n\ndef print_value_changed(value: int, date_time: datetime):\n    print(\"Test object value changed to {} at {}.\".format(\n        value, date_time.isoformat()))\n\n\nif __name__ == \"__main__\":\n    o = Test()\n    o.valueChanged.connect(print_value_changed)\n    o.set_value(5)\n    o.set_value(7)\n    o.valueChanged.disconnect(print_value_changed)\n    o.set_value(10)\n\nPomocí tohoto principu lze mezi objekty v aplikaci předávat různá data i celé objekty."
  },
  {
    "objectID": "06-signály-sloty.html#dočasné-pozastavení-signálů",
    "href": "06-signály-sloty.html#dočasné-pozastavení-signálů",
    "title": "6  Signály a sloty",
    "section": "6.3 Dočasné pozastavení signálů",
    "text": "6.3 Dočasné pozastavení signálů\nV některých situacích může být vhodné či nezbytné, aby jiné objekty či celá aplikace nereagovaly na signály určitého objektu. Toho lze docílit, voláním funkce blockSignals(True) tohoto objektu. Po tomto volání nebudou signály z objektu vyvolávány a tím pádem na ně další objekty nebudou reagovat. Reaktivace se provede voláním stejné funkce s opačným parametrem blockSignals(False).\nPokud do předchozí ukázky doplníte tyto řádky, nebude pro toto nastavení vytištěna zpráva, neboť signál objektu je pozastaven.\n\no.blockSignals(True)\no.set_value(15)\no.blockSignals(False)\n\nV praxi se tohoto využívá např. v situaci, kdy se dva prvky navzájem ovlivňují. Změna na jednom se promítne do změny druhého a opačně, což ale může vést k nekonečné smyčce změn. Pozastavením signálů zamezíme vzniku takovéto nekonečné smyčky. U aplikací s uživatelským rozhraním často nechceme, aby prvky reagovaly na události vyvolané explicitně z kódu, nikoliv interakcí uživatele.\nTento příklad je dostupný jako: signals_slots.py\n\n\n\n\nTAGLIAFERRI, Lisa, 2021. Understanding class and instance variables in python 3 [online] [cit. 2022-08-13]. Dostupné z: https://www.digitalocean.com/community/tutorials/understanding-class-and-instance-variables-in-python-3\n\n\nTHE QT COMPANY LTD., 2022. Layout management [online] [cit. 2022-09-16]. Dostupné z: https://doc.qt.io/qt-5/layout.html\n\n\nWIKIPEDIA, 2022. Observer pattern [online] [cit. 2022-09-12]. Dostupné z: https://en.wikipedia.org/wiki/Observer_pattern"
  },
  {
    "objectID": "07-qwidget-kontejner.html",
    "href": "07-qwidget-kontejner.html",
    "title": "7  QWidget jako základ pro nové prvky",
    "section": "",
    "text": "QWidget je základní třída, z níž většina dalších prvků GUI (widgetů) odvozuje základní chování. Sem patří např. reakce na události v GUI, změny v rozměrech GUI, vykreslení samotné komponenty atd.\nZákladní možností, jak používat QWidget je využít tento prvek jako kontejner pro jiné prvky, s cílem vytvoření nového prvku GUI. Příkladem může být prvek pro výběr souboru, na němž si budeme demonstrovat postup tvorby widgetu. Tento ukázkový widget se bude skládat z textového prvku, zobrazujícího cestu k souboru a jeho název, a tlačítka, které otevře okno pro výběr souboru. Mimo to přidáme ikonu zobrazující, zda-li je aktuálně vybrán soubor. Uživatel bude mít i možnost manuálně zapsat cestu k souboru do textového pole. Výsledný widget by měl být schopný dát okolí vědět, že byl vybrán soubor, i že byl výběr souboru zrušen.\nSamotný widget můžeme testovat spouštěním následující kódu:\nNamísto hlavního okna vytvoříme aplikaci s oknem obsahujícím pouze widget. Pro testování a případně velice jednoduché aplikace je toto možné řešení."
  },
  {
    "objectID": "07-qwidget-kontejner.html#widget-pro-výběr-souboru",
    "href": "07-qwidget-kontejner.html#widget-pro-výběr-souboru",
    "title": "7  QWidget jako základ pro nové prvky",
    "section": "7.1 Widget pro výběr souboru",
    "text": "7.1 Widget pro výběr souboru\n\n\nZdrojový kód\nfrom functools import partial\nimport sys\nimport typing\nfrom pathlib import Path\n\nfrom PyQt5.QtWidgets import (QApplication, QWidget, QHBoxLayout, QToolButton,\n                             QLineEdit, QFileDialog, QAction, QStyle, QLabel)\nfrom PyQt5.QtCore import Qt, pyqtSignal\n\n\nclass FileSelector(QWidget):\n\n    fileSelected = pyqtSignal(str)\n    fileCleared = pyqtSignal()\n\n    def __init__(\n        self,\n        parent: typing.Optional[QWidget] = None,\n        flags: typing.Union[Qt.WindowFlags,\n                            Qt.WindowType] = Qt.WindowType.Widget\n    ) -> None:\n        super().__init__(parent, flags)\n\n        self.init_gui()\n\n        self.dialog = QFileDialog(self, self.tr(\"Select File\"))\n        self.dialog.setFileMode(QFileDialog.ExistingFile)\n\n        icon = self.style().standardIcon(QStyle.SP_DialogCloseButton)\n        self.clear_action = QAction(icon, self.tr(\"Clear Selection\"), self)\n        self.clear_action.setCheckable(False)\n        self.clear_action.triggered.connect(self.clear_value)\n\n        self.path_file = None\n\n    def init_gui(self) -> None:\n        self.setContentsMargins(0, 0, 0, 0)\n\n        layout = QHBoxLayout(self)\n        self.setLayout(layout)\n\n        self.button = QToolButton(self)\n        self.button.setText(\"...\")\n        self.button.clicked.connect(self.show_process_file_dialog)\n        \n        self.text = QLineEdit(self)\n        self.text.setMinimumWidth(150)\n        self.text.textChanged.connect(self.path_defined)\n\n        self.file_selected_label = QLabel()\n        self.set_file_selected_label_icon(False)\n\n        layout.addWidget(self.text)\n        layout.addWidget(self.button)\n        layout.addWidget(self.file_selected_label)\n\n    def set_file_selected_label_icon(self, ok: bool) -> None:\n        if ok:\n            icon = self.style().standardIcon(QStyle.SP_DialogApplyButton)\n        else:\n            icon = self.style().standardIcon(QStyle.SP_CustomBase)\n        self.file_selected_label.setPixmap(\n            icon.pixmap(self.file_selected_label.size()))\n\n    def set_selected_file_dialog(self) -> None:\n        if self.path_file:\n            self.dialog.selectFile(self.path_file)\n        else:\n            self.dialog.setDirectory(Path().expanduser().as_posix())\n            self.dialog.selectFile(None)\n\n    def show_process_file_dialog(self) -> None:\n        self.set_selected_file_dialog()\n        result = self.dialog.exec()\n\n        if result == self.dialog.Accepted:\n            file_name = self.dialog.selectedFiles()[0]\n            if file_name:\n                self.set_existing_file(file_name)\n                self.show_file_path(file_name)\n                self.show_clear_action()\n            else:\n                self.fileCleared.emit()\n\n    def show_clear_action(self) -> None:\n        self.text.addAction(self.clear_action,\n                            QLineEdit.ActionPosition.TrailingPosition)\n\n    def set_existing_file(self, file_name: str) -> None:\n        self.path_file = file_name\n        self.fileSelected.emit(self.path_file)\n        self.set_file_selected_label_icon(True)\n\n    def show_file_path(self, path: str) -> None:\n        self.text.blockSignals(True)\n        self.text.setText(path)\n        self.text.blockSignals(False)\n\n    def path_defined(self) -> None:\n        self.show_clear_action()\n        path = Path(self.text.text())\n\n        if path.exists() and path.is_file():\n            if path.absolute().as_posix() != self.path_file:\n                self.set_existing_file(self.text.text())\n        else:\n            self.clear_file()\n\n    def clear_file(self) -> None:\n        shouldSignalEmit = self.path_file is not None\n        self.path_file = None\n        self.set_file_selected_label_icon(False)\n        if shouldSignalEmit:\n            self.fileCleared.emit()\n\n    def clear_value(self) -> None:\n        self.show_file_path(\"\")\n        self.text.removeAction(self.clear_action)\n        self.clear_file()\n\n\ndef print_file(file: str) -> None:\n    print(file)\n\n\nif __name__ == \"__main__\":\n\n    app = QApplication(sys.argv)\n    w = FileSelector()\n    w.fileSelected.connect(print_file)\n    w.fileCleared.connect(partial(print_file, \"Cleared\"))\n    w.show()\n    sys.exit(app.exec())\n\n\nPři vytvoření objektu se zaměříme na dvě hlavní položky. Inicializace uživatelského rozhraní pomocí funkce init_gui() a následně dalších objektů a proměnných pro widget.\nVe funkci init_gui() je většina kódu už známá z předchozích kapitol. Pouze několik, řádků zaslouží krátké vysvětlení. Následující řádek, nastaví odsazení prvků widgetu od okrajů na 0, což znamená, že prvky zcela vyplní widget. To zabrání “odsazení” dílčích částí widgetu od odstaních položek komplexnějšího uživatelského rozhraní.\n\nself.setContentsMargins(0, 0, 0, 0)\n\nPro prvky widgetu použijeme layout, který řadí prvky horizontálně do jedné linie.\n\nlayout = QHBoxLayout(self)\n\nMimo to si ve widgetu vytvoříme proměnné s objekty dialogového okna pro výběr souboru, které nastavíme na možnost výběru pouze jednoho souboru, a akci, kterou budeme používat pro vymázání textového pole. K této akci připojíme funkci self.clear_value(). Posledním prvkem, který vytvoříme, je proměnná, v níž bude uložena cesta k vybranému souboru. Do začátku tato hodnota bude None, neboť soubor není vybrán.\n\nself.dialog = QFileDialog(self, self.tr(\"Select File\"))\nself.dialog.setFileMode(QFileDialog.ExistingFile)\n\nicon = self.style().standardIcon(QStyle.SP_DialogCloseButton)\nself.clear_action = QAction(icon, self.tr(\"Clear Selection\"), self)\nself.clear_action.setCheckable(False)\nself.clear_action.triggered.connect(self.clear_value)\n\nself.path_file = None\n\nFunkce vytvořeného widgetu jsou relativně jednoduché, ale jejich propojení vytváří komplexní funkcinalitu. Pokusíme se shrnout účel a použití jednotlivých funkcí.\nFunkce show_clear_action() se stará o připojení vytvořené akce (self.clear_action) k textovému poli pro zápis cesty k souboru (v proměnné self.text). Funkci jsme vytvořili proto, aby se nám tento kód neopakoval na různých místech v kódu.\n\ndef show_clear_action(self) -> None:\n    self.text.addAction(self.clear_action,\n                        QLineEdit.ActionPosition.TrailingPosition)\n\nDalší funkcí modifikující, jak widget vypadá, je funkce set_file_selected_label_icon(). Tato funkce nastaví ikonu, zde používáme standardní ikony Qt, dle vstupní proměnné funkce. Tuto ikonu, respektive její vykreslenou podobu, vložíme do dříve vytvořené proměnné self.file_selected_label. V případě, že vstupní proměnná ok byla hodnoty True použijeme ikonu “zatrženo”, v opačném případě použijeme prázdnou ikonu.\n\ndef set_file_selected_label_icon(self, ok: bool) -> None:\n    if ok:\n        icon = self.style().standardIcon(QStyle.SP_DialogApplyButton)\n    else:\n        icon = self.style().standardIcon(QStyle.SP_CustomBase)\n    self.file_selected_label.setPixmap(\n        icon.pixmap(self.file_selected_label.size()))\n\nDalší funkcí, kterou budeme potřebovat, je nastavení cesty k souboru do textového pole (self.text), v situaci, kdy ho uživatel vybere skrze dialogové okno. To není problematické, ale je třeba si uvědomit, že na signálu daného objektu je připojený slot (funkce) a dočasně pozastavit signály, aby nebyly vyvolány nezamýšlené akce.\n\ndef show_file_path(self, path: str) -> None:\n    self.text.blockSignals(True)\n    self.text.setText(path)\n    self.text.blockSignals(False)\n\nPro dialogové okno, kde uživatel vybírá soubor, můžeme připravit zajímavou pomocnou funkci. Pokud máme ve widgetu už vybraný soubor, přednastavíme dialogové okno do lokace soubor a tento soubor předvybereme. Pokud nemáme vybraný soubor přednastavíme cestu do lokace uživatelských dat (závislé na platformě a uživatelském nastavení v systému).\n\ndef set_selected_file_dialog(self) -> None:\n    if self.path_file:\n        self.dialog.selectFile(self.path_file)\n    else:\n        self.dialog.setDirectory(Path().expanduser().as_posix())\n        self.dialog.selectFile(None)\n\nDalší funkcí, kterou potřebujeme je funce, která nastavíme widgetu vybraný soubor, vyvolá signál výběru souboru a nastaví ikonu, vybraného souboru.\n\ndef set_existing_file(self, file_name: str) -> None:\n    self.path_file = file_name\n    self.fileSelected.emit(self.path_file)\n    self.set_file_selected_label_icon(True)\n\nNásledně už se můžeme věnovat funkci, která otevře dialogové okno. Nejdříve oknu nastavíme vhodnou výchozí cestu a případně vybraný soubor. Pak samotné okno otevřeme. Funkce self.dialog.exec() po zavření okna vrací hodnotu, kterou uložíme do proměnné. Pokud bylo okno zavřeno potvrzením, pak informace dále zpracováváme. Pokud bylo zavřeno jinak, žadné další akce neprovádíme. V případně korektního výběru souboru nám funkce self.dialog.selectedFiles() vrátí seznam vybraných souborů. Tím, že jsme se omezili pouze na výběr jednoho, můžeme rovnou ze seznamu extrahovat první prvek, jímž je absolutní cesta k vybranému souboru. Následně voláním funkcí nastavíme widgetu do stavu, v němž má být po výběru souboru. Pokud by první prvek seznamu souborů neexistoval, vyvoláme signál informující, že není vybrán žádný soubor.\n\ndef show_process_file_dialog(self) -> None:\n    self.set_selected_file_dialog()\n    result = self.dialog.exec()\n\n    if result == self.dialog.Accepted:\n        file_name = self.dialog.selectedFiles()[0]\n        if file_name:\n            self.set_existing_file(file_name)\n            self.show_file_path(file_name)\n            self.show_clear_action()\n        else:\n            self.fileCleared.emit()\n\nDalší možností, jak může být soubor ve widgetu zadán, je uživatelsky zapsaná cesta k existujícímu souboru. Ke slotu textChanged proměnné text připojíme funkci, která verifikuje, zda-li zapsaná cesta odpovídá existujícímu souboru. Pokud ano, cestu k souboru uložíme do proměnné a vyvoláme odpovídající signál. Pokud soubor neexistuje, zavolám funkci, která se postará o nastavení widgetu do vychózího stavu.\n\ndef path_defined(self) -> None:\n    self.show_clear_action()\n    path = Path(self.text.text())\n\n    if path.exists() and path.is_file():\n        if path.absolute().as_posix() != self.path_file:\n            self.set_existing_file(self.text.text())\n    else:\n        self.clear_file()\n\nPoslední dvě funkce, které nám zbyvají ve widgetu, jsou funkce clear_value() a clear_file(). První z nich je napojená na akci (QAction) clear_action, která se stará o odstranění textu z proměnné text, skrytí ikony příslušné akce, a následně odstranění souboru z příslušné proměnné. O toto odstranění souboru se stará funkce clear_file(), která nastavuje proměnou path_file na hodnotu None, odstraní ikonu z widgetu a pokud je to nutné vyvolá signál fileCleared.\n\ndef clear_value(self) -> None:\n    self.show_file_path(\"\")\n    self.text.removeAction(self.clear_action)\n    self.clear_file()\n\ndef clear_file(self) -> None:\n    shouldSignalEmit = self.path_file is not None\n    self.path_file = None\n    self.set_file_selected_label_icon(False)\n    if shouldSignalEmit:\n        self.fileCleared.emit()\n\nNa tomto jednoduchém widgetu, lze demonstrovat komplexnost tvorby prvků UI. Ačkoliv se jedná o poměrně jednoduchý widget, jeho funkcionalitu pokrývá řada funkcí, které musejí předpokládat řadu možných situací, které mohou nastat.\n\n\n  \n  \n  \n  \n  \n  QGIS\n  \n  \n  \n  \nQGIS obsahuje celou řadu prvků UI, které jsou pro tento software specifické, nebo upravují chování běžných prvků Qt. Výpis všech těchto prvů je v nápovědě modulu qgis.gui.\n\n      \n      \n\nVýsledný widget je spustitelný z této ukázky: file_select_widget.py."
  },
  {
    "objectID": "08-narocne-operace.html",
    "href": "08-narocne-operace.html",
    "title": "8  Časově náročné operace v GUI",
    "section": "",
    "text": "Jedním ze základních problémů aplikací s uživatelským rozhraním, je responzivita, což je schopnost reagovat na akce uživatele v reálném čase (Ramos 2021). Pakliže nebude aplikace reagovat na akce uživatele v reálném čase, pak nebude příliš uživatelsky přívětivá a ani použitelná (Fitzpatrick 2021). Tuto situaci v praxi znají všichni uživatelé, aplikace občas “zamrzne, zatuhne”, přičemž v některých případech dojde po chvíli k obnovení responzivity a někdy je nutné aplikaci nestandardně ukončit (např. použitím Task manageru). Důvody proč k tomuto dochází mohou být různé, od chyb až po náročnost některých operací.\nV této kapitole se specificky zaměříme na operace, které trvají delší dobu, a z hlediska uživatele by způsobovaly “zamrznutí” aplikace. V této terminologii lze za dlouho běžící operaci označit jakoukoliv operaci, jejíž zpracování překročí cca 0.5 vteřiny. Tento čas už uživatel zvládne vnímat a rozpozná, že v aplikaci “něco nefunguje”. Běžné změny v GUI, vykreslení prvků GUI atd. obvykle zaberou řádově pouze setiny vteřiny, proto je vhodné cokoliv delšího spouštět tak, aby to neomezovalo uživatele v interakci s GUI, zároveň je ale nezbytné dát uživateli nějakým způsobem vědět, že operace probíhá na pozadí a pokud je to možné, tak ho informovat o stavu této operace (např. zpracovaná procenta)."
  },
  {
    "objectID": "08-narocne-operace.html#spouštení-procesu-bez-blokace-gui",
    "href": "08-narocne-operace.html#spouštení-procesu-bez-blokace-gui",
    "title": "8  Časově náročné operace v GUI",
    "section": "8.1 Spouštení procesu bez blokace GUI",
    "text": "8.1 Spouštení procesu bez blokace GUI\nZákladním krokem je vytvoření objektu, který odvodíme z třídy QRunnable. Tato třída vytváří objekty, obsahující komplexní úlohy, které je možné snadno spouštět. Klíčovou roli hraje funkce run třídy QRunnable, která se spouští a měla by obsahovat dlouho běžící úlohu.\nV příkladu pod odstavcem vytvoříme třídu Worker, pro kterou vytvoříme konstruktor, abychom demonstrovali, jak je možné do úlohy předat data. Mimo to v této třídě vytvoříme tři signály, s ohledem na omezení kombinace Pythonu a [PyQt]]{.software} nelze signály vytvořit přímo na objektu QRunnable. Je nutné pro signály vytvořit vlastní třídu a tu následně použít jako proměnnou ve třídě odvozené od QRunnable (Fitzpatrick 2021). Jeden informuje o ukončení této úlohy, druhý předává výslednou hodnotu a třetí slouží pro informování kolik procent úlohy už je zpracováno a název Worker, který běží. V tomto případě používáme jako vstup i výstup jednoduché texty, ale lze takto předávat i komplexnější data či celé objekty. Worker v ukázkovém příkladu nic specifického nevykonává, pouze 10 krát jednu sekundu vyčkává, abychom demonstrovali dlouho běžící process.\n\n\nZdrojový kód\nimport time\n\nfrom PyQt5.QtCore import QRunnable, pyqtSignal, QObject\n\nclass WorkerSignals(QObject):\n    finished = pyqtSignal()\n    percentDone = pyqtSignal(str, float)\n    result = pyqtSignal(str)\n\nclass Worker(QRunnable):\n\n    def __init__(self, job_name: str):\n        super(Worker, self).__init__()\n        self.signal = WorkerSignals()\n        self.job_name = job_name\n\n    def run(self):\n        for i in range(10):\n            time.sleep(1)\n            self.signal.percentDone.emit(self.job_name, (i / 10) * 100)\n        self.signal.finished.emit()\n        self.signal.result.emit(\"Job `{}` is done.\".format(self.job_name))\n\n\nTuto vytvořenou třídu může následně využít. Lze ji použít přímo z hlavního okna aplikace, či jakékoliv jiné dílčí komponenty. Je pouze nutné při inicializaci této komponenty vytvořit proměnnou třídy QThreadPool, která se postará o spouštění tříd odvozených z QRunnable. Tvorba této proměnné vypadá následovně.\n\nself.threadpool = QThreadPool()\n\nMimo je nutné vytvořit v této třídě funkci, která bude instance třídy Worker vytvářet a předávat je ke spuštění do třídy QThreadPool. To je nezbytné minimum, nad rámec toho je možné k signálům třídy Worker připojit sloty (funkce), které budou na vyvolání signálů reagovat. V tomto ukázkovém případě pouze tiskem informačních zpráv, nicméně funkce mohou být libovolně komplexní.\nV kódu používáme uuid, pomocí nějž generujeme náhodné unikátní označení uuid.uuid4(), respektive jeho část, pro každou instanci třídy Worker.\nVýsledné funkce, které použijeme v kódu příslušné třídy, pak vypadají následovně:\n\nimport uuid\n\ndef run_worker(self):\n    worker_id = str(uuid.uuid4()).split(\"-\")[0]\n    worker = Worker(worker_id)\n\n    worker.signal.result.connect(self.print_worker_output)\n    worker.signal.finished.connect(self.worker_finished)\n    worker.signal.percentDone.connect(self.worker_percent_done)\n\n    self.threadpool.start(worker)\n\ndef print_worker_output(self, output: str):\n    print(output)\n\ndef worker_finished(self):\n    print(\"Worker finished!\")\n\ndef worker_percent_done(self, worker_name: str, percent: float):\n    msg = \"Done {}%. ({})\".format(percent, worker_name)\n    print(msg)\n\nTento postup funguje v momentech kdy jednotlivé instance třídy Worker neupravují stejná data a ani si jinak vzájemně nekonkurují, co se týká zdrojů. Pakliže by bylo nutné řešit konkurenci úloh, jsou nutné pokročilejší postupy a přístupy k managementu dat a procesů Ramos (2021)."
  },
  {
    "objectID": "08-narocne-operace.html#praktická-ukázka",
    "href": "08-narocne-operace.html#praktická-ukázka",
    "title": "8  Časově náročné operace v GUI",
    "section": "8.2 Praktická ukázka",
    "text": "8.2 Praktická ukázka\nUkázkou aplikace, na níž je možné demonstrovat výše zmíněné koncepty a úskalí práce s GUI je ukázka long_running_tasks.py. Tato aplikace umožňuje vyzkoušení jak se chová aplikace při spuštění naivní úlohy (tlačítko Create Long Running Taks) v porovnání s úlohou spouštěnou skrze Threadpool (tlačítko Create Worker) (viz Obr. 8.1). Během toho, co jsou tyto úlohy aktivní, lze otestovat zda-li je aplikace responzivní pomocí tlačítka Test Interactivity, které by mělo okamžitě vypsat text Clicked at: aktuální datum a čas do QPlainTextEdit umístěného pod tímto tlačítkem.\n\n\n\nObr. 8.1: Aplikace pro testování interaktivity pro déle běžící úlohy\n\n\n\n\n\n\nFITZPATRICK, Martin, 2021. Multithreading PyQt5 applications with QThreadPool [online] [cit. 2022-09-16]. Dostupné z: https://www.pythonguis.com/tutorials/multithreading-pyqt-applications-qthreadpool/\n\n\nMOORE, Alan D, 2019. Mastering GUI programming with python: Develop impressive cross-platform GUI applications with PyQt. Birmingham: Packt Publishing Ltd. ISBN 978-1-78961-290-5.\n\n\nRAMOS, Leodanis Pozo, 2021. Use PyQt’s QThread to prevent freezing GUIs [online] [cit. 2022-09-16]. Dostupné z: https://realpython.com/python-pyqt-qthread/"
  },
  {
    "objectID": "09-pretrvavajici_nastaveni_aplikace.html",
    "href": "09-pretrvavajici_nastaveni_aplikace.html",
    "title": "9  Přetrvávající nastavení aplikace",
    "section": "",
    "text": "Jedním nedostatkem, kterým může aplikace trpět, je že po startu se bude vždy nacházet ve výchozím stavu. Což reálně znamená, že si aplikace nepřenáší mezi jednotlivými spuštěními žádnou informaci o svém stavu. U jednoduchých aplikací to nemusí vadit, byť i zde si lze představit informace, které by si aplikace mohla přenést, např. velikost a umístění okna na obrazovce.\nPro uložení nejen těchto, ale libovolných jiných, informací applikace je možné použít třídu QSettings, která je přímo pro tyto situace vytvořena. Tato třída má dva režimy, ve kterých může fungovat. Jednou variantou je vytvoření .ini soubor v definovaném umístění, což je textový soubor, do které se nastavení zapisují. Takovýto soubor vytvoříme následovně:\nDruhou variantou je nastavení proměnných QApplication organizace, domény a názvu aplikace, a následně vytvoření settings bez udání dalších informací. V tomto případě Qt{.software} zvolí umístění souboru dle systému a několika dalších informací autonomně a formát nebude textový .ini soubor. Tato varianta je obecnější, ale náročnější, protože programátor nemá k přímo přístup k souboru a informacím v něm uloženým.\nJakmile existuje proměnná s nastaveními, je důležité znát několik základních funkcí pro práci s nastaveními. Samotná třída QApplication obsahuje širší funkcionalitu, ale tyto funkce jsou zásadní. Základními funkcemi je zápis a přečtení proměnné, což je realizováno funkcemi setValue() a value(). Obě tyto funkce mají jako první parameter název příslušného nastavení, v němž je možné použít / jako oddělovač úrovní. Funkce value() umožňuje jako druhý parametr definovat defaultní hodnotu nastavení, pokud zatím není nastavená a neexistuje.\nDvě další zásadní funkce jsou vymazání proměnné (remove()) a kontrola, zdali proměnná existuje (contains()), obě funkce přijímají jako první parameter název nastavení.\nQt{.software} umožňuje do nastavení ukládat a následně načítat i některé komplexnější objekty, např. velikost (třída QSize) či umístění (třída QPoint), což značně usnadňuje mnoho operací. Např. je tak možné jednoduše ukládat do nastavení velikost a umístění oken na obrazovce."
  },
  {
    "objectID": "09-pretrvavajici_nastaveni_aplikace.html#praktická-ukázka",
    "href": "09-pretrvavajici_nastaveni_aplikace.html#praktická-ukázka",
    "title": "9  Přetrvávající nastavení aplikace",
    "section": "9.1 Praktická ukázka",
    "text": "9.1 Praktická ukázka\nPraktická ukázka zde zahrnuje prázdnou aplikaci, která si pamatuje svoje umístění a velikost na obrazovce. Ukázka je dostupná: empty_application_with_settings.py. V ukázce je podstatné, že velikost a umístění okna se zapisují do nastavení při každé jejich změně, a načítají se při vytvoření hlavní okna aplikace."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "10  Summary",
    "section": "",
    "text": "from platform import python_version\nfrom PyQt5.QtCore import QT_VERSION_STR\nfrom PyQt5.Qt import PYQT_VERSION_STR\nfrom sip import SIP_VERSION_STR\nfrom osgeo import gdal\n\nprint(\"Python version:\", python_version())\nprint(\"Qt version:\", QT_VERSION_STR)\nprint(\"SIP version:\", SIP_VERSION_STR)\nprint(\"PyQt version:\", PYQT_VERSION_STR)\nprint(\"GDAL version:\", gdal.__version__)\n\nPython version: 3.8.10\nQt version: 5.15.2\nSIP version: 6.6.2\nPyQt version: 5.15.7\nGDAL version: 3.4.3"
  },
  {
    "objectID": "literatura.html",
    "href": "literatura.html",
    "title": "Literatura",
    "section": "",
    "text": "COSTA, Claire D., 2020. Top 10 Python GUI Frameworks for\nDevelopers [online] [vid. 2022-08-01]. Dostupné z: https://towardsdatascience.com/top-10-python-gui-frameworks-for-developers-adca32fbe6fc\n\n\nERICKSON, Jared, Cort DANIEL a Michael PAYNE, 2013. Python GDAL/OGR\nCookbook [online]. Dostupné z: https://pcjericks.github.io/py-gdalogr-cookbook/\n\n\nFITZPATRICK, Martin, 2021. Multithreading PyQt5 applications with\nQThreadPool [online] [vid. 2022-09-16]. Dostupné z: https://www.pythonguis.com/tutorials/multithreading-pyqt-applications-qthreadpool/\n\n\nGARRARD, Chris, 2016. Geoprocessing With Python. Shelter\nIsland, NY: Manning Publications. ISBN 978-1-61729-214-9.\n\n\nGDAL/OGR CONTRIBUTORS, 2022. GDAL/OGR Geospatial Data\nAbstraction software Library [online]. B.m.: Open Source Geospatial\nFoundation. Dostupné z: https://gdal.org\n\n\nMOORE, Alan D, 2019. Mastering GUI programming with\nPython: develop impressive cross-platform GUI applications\nwith PyQt. Birmingham: Packt Publishing Ltd.\nISBN 978-1-78961-290-5.\n\n\nPYTHON SOFTWARE FOUNDATION, 2022. typing — Support for type\nhints [online]. Dostupné z: https://docs.python.org/3.8/library/typing.html\n\n\nRAMOS, Leodanis Pozo, 2021. Use PyQt’s QThread to Prevent Freezing\nGUIs [online] [vid. 2022-09-16]. Dostupné z: https://realpython.com/python-pyqt-qthread/\n\n\nTAGLIAFERRI, Lisa, 2021. Understanding Class and Instance Variables\nin Python 3 [online] [vid. 2022-08-13]. Dostupné z: https://www.digitalocean.com/community/tutorials/understanding-class-and-instance-variables-in-python-3\n\n\nTHE QT COMPANY LTD., 2022a. Layout Management [online]\n[vid. 2022-09-16]. Dostupné z: https://doc.qt.io/qt-5/layout.html\n\n\nTHE QT COMPANY LTD., 2022b. Qt 5.15 [online] [vid. 2022-08-13].\nDostupné z: https://doc.qt.io/qt-5/\n\n\nWIKIPEDIA, 2022. Observer pattern [online] [vid. 2022-09-12].\nDostupné z: https://en.wikipedia.org/wiki/Observer_pattern"
  },
  {
    "objectID": "appendix.html",
    "href": "appendix.html",
    "title": "Funkce GDAL",
    "section": "",
    "text": "Listing 1: Customers Query\nSELECT * FROM Customers"
  }
]